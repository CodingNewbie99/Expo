---
title: Custom JavaScript/TypeScript functions
description: Learn how to create and use custom JavaScript/TypeScript functions in your EAS Build custom builds configuration.
---

import { Terminal } from '~/ui/components/Snippet';
import { Step } from '~/ui/components/Step';
import ImageSpotlight from '~/components/plugins/ImageSpotlight';
import { BoxLink } from '~/ui/components/BoxLink';
import { GithubIcon } from '@expo/styleguide-icons';

Custom functions are a great way to extend the functionality of EAS Build custom builds. You can use them to write reusable pieces of custom build config in a very powerful and convenient way.

<Step label="1">

## Creating custom JavaScript/TypeScript functions

The easiest way to create a custom function is to use the `create-eas-build-function` CLI tool.

By running the following command, from the same as your `eas.json` file, you will be able to create a new custom TypeScript function:

<Terminal cmd={['$ npx create-eas-build-function@latest ./.eas/build/myFunction']} />

This will create a new module called `myFunction` in your `.eas/build` directory. The module will contain a pre-generated module configuration and the `src` directory with the `index.ts` file containing the default TypeScript function template.

```ts .eas/build/myFunction/src/index.ts
// This file was autogenerated by `create-eas-build-function` command.
// Go to README.md to learn more about how to write your own custom build functions.

import { BuildStepContext } from '@expo/steps';

// interface FunctionInputs {
//   // specify the type of the inputs value and whether they are required here
//   // example: name: BuildStepInput<BuildStepInputValueTypeName.STRING, true>;
// }

// interface FunctionOutputs {
//   // specify the function outputs and whether they are required here
//   // example: name: BuildStepOutput<true>;
// }

async function myFunction(
  ctx: BuildStepContext
  // {
  //   inputs,
  //   outputs,
  //   env,
  // }: {
  //   inputs: FunctionInputs;
  //   outputs: FunctionOutputs;
  //   env: BuildStepEnv;
  // }
): Promise<void> {
  ctx.logger.info('Hello from my TypeScript function!');
}

export default myFunction;
```

</Step>

<Step label="2">

## Building your custom function and connecting it to your config file

After generating the custom build function next thing you need to do is to build it and connect it to your eas build custom builds config YAML file.

### Building your custom function

To build your custom function you need to run the following command in `.eas/build/myFunction` directory:

<Terminal cmd={['$ npm run build']} />

This command will trigger the `build` script placed in the `package.json` file of your custom function module.

```json package.json
{
  ...
  "scripts": {
    ...
    "build": "ncc build ./src/index.ts -o build/ --minify --no-cache --no-source-map-register" /* @end */
    ...
  },
  ...
}
```

> **Info** The `build` script uses the [ncc](https://github.com/vercel/ncc) to compile your custom function module into a single file with all its dependencies. If you don't have the `ncc` installed globally on your machine, run `npm install -g @vercel/ncc` to install it.

The `build` script will generate the `build/index.js` file which will be used by the EAS Build to run your custom function.

> **Warning** The `build/index.js` file must be uploaded to EAS Build as a part of your project archive so the EAS Build builder can run your custom function. Make sure it's not excluded by your `.gitignore` file or `.easignore` file.

### Connecting the custom function to your config file

Let's assume that except from `myFunction` you also have a `config.yml` file in your `.eas/build` directory. The file contains the following content:

```yaml .eas/build/config.yml
build:
  name: My example config
  steps:
    - eas/checkout
    - run:
        name: Install dependencies
        command: npm install
    - run:
        name: Finished
        command: echo Finished
```

To add your custom function to the config you need to add the following lines to the `config.yml` file:

```yaml .eas/build/config.yml
build:
  name: My example config
  steps:
    - eas/checkout
    - run:
        name: Install dependencies
        command: npm install
    - run:
        name: Finished
        command: echo Finished

# @info #
functions:
  my_function:
    name: My function
    path: ./myFunction
# @end #
```

The `path` property should be a relative path from the config file to your custom function module. In this case, it's just `./myFunction`.

Now we can add a call to the `my_function` function in the `config.yml` file:

```yaml .eas/build/config.yml
build:
  name: My example config
  steps:
    - eas/checkout
    - run:
        name: Install dependencies
        command: npm install
    # @info #
    - my_function
    # @end #
    - run:
        name: Finished
        command: echo Finished

functions:
  my_function:
    name: My function
    path: ./myFunction
```

<ImageSpotlight
  alt="Example of a custom build config using custom JavaScript/TypeScript function."
  src="/static/images/eas-build/custom-build-function.png"
/>

</Step>

<Step label="3">

## Modyfing and developing your custom function

Let's consider a little bit more advanced example. Let's say that we want to make our custom function sum two numbers and print the result to the console, and save it as an output of the function.

To do so we can modify the `config.yml` and `index.ts` files to make the function accept two inputs called `num1` and `num2` and return the sum of them as an output called `sum`.

```yaml .eas/build/config.yml
build:
  name: My example config
  steps:
    - eas/checkout
    - run:
        name: Install dependencies
        command: npm install
    # @info #
    - my_function:
        inputs:
          num1: 1
          num2: 2
        id: sum_function
    # @end #
    - run:
        name: Print the sum
        inputs:
          sum: ${ steps.sum_function.sum }
        command: echo ${ inputs.sum }
    - run:
        name: Finished
        command: echo Finished

functions:
  my_function:
    name: My function
    # @info #
    inputs:
      - name: num1
        type: number
      - name: num2
        type: number
    outputs:
      - name: sum
    # @end #
    path: ./myFunction
```

```ts .eas/build/myFunction/src/index.ts
// This file was autogenerated by `create-eas-build-function` command.
// Go to README.md to learn more about how to write your own custom build functions.

import {
  BuildStepContext,
  BuildStepInput,
  BuildStepInputValueTypeName,
  BuildStepOutput,
} from '@expo/steps';

/* @info */
interface FunctionInputs {
  // first template argument is the type of the input value, second template argument is a boolean indicating if the input is required
  num1: BuildStepInput<BuildStepInputValueTypeName.NUMBER, true>;
  num2: BuildStepInput<BuildStepInputValueTypeName.NUMBER, true>;
}
/* @end */

/* @info */
interface FunctionOutputs {
  // template argument is a boolean indicating if the output is required
  sum: BuildStepOutput<true>;
}
/* @end */

async function myFunction(
  ctx: BuildStepContext,
  {
    inputs,
    outputs,
  }: // env,
  {
    inputs: FunctionInputs;
    outputs: FunctionOutputs;
    // env: BuildStepEnv;
  }
): Promise<void> {
  /* @info */
  ctx.logger.info(`num1: ${inputs.num1.value}`);
  ctx.logger.info(`num2: ${inputs.num2.value}`);

  const sum = inputs.num1.value + inputs.num2.value;

  ctx.logger.info(`sum: ${sum}`);

  outputs.sum.set(sum.toString()); // for now outputs can only of string type, but that will change in the future
  /* @end */
}

export default myFunction;
```

<ImageSpotlight
  alt="Example of a custom build config using custom JavaScript/TypeScript function."
  src="/static/images/eas-build/custom-build-function-advanced.png"
/>

> **Info** Remember to rebuild your custom function after making any changes to it.

</Step>

## Summary

- Custom JavaScript/TypeScript functions are a great way to extend the EAS Build custom builds functionality with your custom logic, in a pleasant way, by writing JavaScript/TypeScript code.
- Custom JavaScript/TypeScript functions are reusable and can be used in multiple workflows.
- Using custom JavaScript/TypeScript functions is a great option for more advanced use cases that are not easy to do by writing shell scripts.
- Most of our [built-in functions](/eas-build-custom-builds/custom-build-config-schema/#built-in-eas-functions) are open-sourced and can be used as a reference for writing your own custom functions.

Also, check out the **example repository** for more detailed examples:

<BoxLink
  title="Custom build example repository"
  description="A custom EAS Build example that includes examples for workflows such as setting up functions, using environment variables, uploading artifacts, and more."
  Icon={GithubIcon}
  href="https://github.com/expo/eas-custom-builds-example/tree/main"
/>
