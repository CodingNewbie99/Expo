---
title: EAS Build functions
description: Learn how to create and use EAS Build functions in your custom builds configuration.
---

import { Terminal } from '~/ui/components/Snippet';
import { Step } from '~/ui/components/Step';
import ImageSpotlight from '~/components/plugins/ImageSpotlight';
import { BoxLink } from '~/ui/components/BoxLink';
import { GithubIcon } from '@expo/styleguide-icons';

EAS Build functions are a great way to extend the functionality of EAS Build custom builds. You can use them to write reusable pieces of custom build config in a very powerful and convenient way. This guide provides a walkthrough.

<Step label="1">

## Create EAS Build function

The easiest way to create an EAS Build function is to use the `create-eas-build-function` CLI tool. By running the following command from the same directory as your **eas.json** file, you can create a new custom TypeScript function:

<Terminal cmd={['$ npx create-eas-build-function@latest ./.eas/build/myFunction']} />

This creates a new module called `myFunction` in the **.eas/build** directory. The module will contain a pre-generated module configuration and the **src** directory with the **index.ts** file containing the default TypeScript function template.

```ts .eas/build/myFunction/src/index.ts
// This file was autogenerated by `create-eas-build-function` command.
// Go to README.md to learn more about how to write your own custom build functions.

import { BuildStepContext } from '@expo/steps';

// interface FunctionInputs {
//   // specify the type of the inputs value and whether they are required here
//   // example: name: BuildStepInput<BuildStepInputValueTypeName.STRING, true>;
// }

// interface FunctionOutputs {
//   // specify the function outputs and whether they are required here
//   // example: name: BuildStepOutput<true>;
// }

async function myFunction(
  ctx: BuildStepContext
  // {
  //   inputs,
  //   outputs,
  //   env,
  // }: {
  //   inputs: FunctionInputs;
  //   outputs: FunctionOutputs;
  //   env: BuildStepEnv;
  // }
): Promise<void> {
  ctx.logger.info('Hello from my TypeScript function!');
}

export default myFunction;
```

</Step>

<Step label="2">

## Build the EAS Build function and connect it to the config file

After generating the custom build function, the next thing you need to do is to build it and connect it to your EAS Build custom builds config YAML file.

### Build the EAS Build function

To build the custom function you need to run the following command in **.eas/build/myFunction** directory:

<Terminal cmd={['$ npm run build']} />

This command triggers the `build` script placed in the **package.json** file of your custom function module.

```json package.json
{
  ...
  "scripts": {
    ...
    "build": "ncc build ./src/index.ts -o build/ --minify --no-cache --no-source-map-register" /* @end */
    ...
  },
  ...
}
```

> **Info** The `build` script uses the [ncc](https://github.com/vercel/ncc) to compile your custom function module into a single file with all its dependencies. If you don't have the `ncc` installed globally on your machine, run `npm install -g @vercel/ncc` to install it.

The `build` script generates the **build/index.js** file that is used by the EAS Build to run your custom function.

> **Warning** The **build/index.js** file must be uploaded to EAS Build as a part of your project archive so the EAS Build builder can run your custom function. Make sure it's not excluded by **.gitignore** file or **.easignore** file.

### Connect the custom function to the config file

Let's assume that except from `myFunction`, you have a **config.yml** file in the **.eas/build** directory. It contains the following content:

```yaml .eas/build/config.yml
build:
  name: My example config
  steps:
    - eas/checkout
    - run:
        name: Install dependencies
        command: npm install
    - run:
        name: Finished
        command: echo Finished
```

To add your custom function to the config, you need to add the following lines to the **config.yml** file:

```yaml .eas/build/config.yml
build:
  name: My example config
  steps:
    - eas/checkout
    - run:
        name: Install dependencies
        command: npm install
    - run:
        name: Finished
        command: echo Finished

# @info #
functions:
  my_function:
    name: My function
    path: ./myFunction
# @end #
```

The `path` property should be a relative path from the config file to your custom function module. In this case, it's just `./myFunction`.

Now, add a call to the `my_function` function in the **config.yml** file:

```yaml .eas/build/config.yml
build:
  name: My example config
  steps:
    - eas/checkout
    - run:
        name: Install dependencies
        command: npm install
    # @info #
    - my_function
    # @end #
    - run:
        name: Finished
        command: echo Finished

functions:
  my_function:
    name: My function
    path: ./myFunction
```

<ImageSpotlight
  alt="Example of a custom build config using custom JavaScript/TypeScript function."
  src="/static/images/eas-build/custom-build-function.png"
/>

</Step>

<Step label="3">

## Modify and develop the custom function

Consider an advanced example. Let's say you want to make a custom function sum two numbers and print the result to the console, and save it as an output of the function. To do so, you can modify the **config.yml** and **index.ts** files to make the function accept two inputs called `num1` and `num2` and return the sum of them as an output called `sum`.

```yaml .eas/build/config.yml
build:
  name: My example config
  steps:
    - eas/checkout
    - run:
        name: Install dependencies
        command: npm install
    # @info #
    - my_function:
        inputs:
          num1: 1
          num2: 2
        id: sum_function
    # @end #
    - run:
        name: Print the sum
        inputs:
          sum: ${ steps.sum_function.sum }
        command: echo ${ inputs.sum }
    - run:
        name: Finished
        command: echo Finished

functions:
  my_function:
    name: My function
    # @info #
    inputs:
      - name: num1
        type: number
      - name: num2
        type: number
    outputs:
      - name: sum
    # @end #
    path: ./myFunction
```

```ts .eas/build/myFunction/src/index.ts
// This file was autogenerated by `create-eas-build-function` command.
// Go to README.md to learn more about how to write your own custom build functions.

import {
  BuildStepContext,
  BuildStepInput,
  BuildStepInputValueTypeName,
  BuildStepOutput,
} from '@expo/steps';

/* @info */
interface FunctionInputs {
  // first template argument is the type of the input value, second template argument is a boolean indicating if the input is required
  num1: BuildStepInput<BuildStepInputValueTypeName.NUMBER, true>;
  num2: BuildStepInput<BuildStepInputValueTypeName.NUMBER, true>;
}
/* @end */

/* @info */
interface FunctionOutputs {
  // template argument is a boolean indicating if the output is required
  sum: BuildStepOutput<true>;
}
/* @end */

async function myFunction(
  ctx: BuildStepContext,
  {
    inputs,
    outputs,
  }: // env,
  {
    inputs: FunctionInputs;
    outputs: FunctionOutputs;
    // env: BuildStepEnv;
  }
): Promise<void> {
  /* @info */
  ctx.logger.info(`num1: ${inputs.num1.value}`);
  ctx.logger.info(`num2: ${inputs.num2.value}`);

  const sum = inputs.num1.value + inputs.num2.value;

  ctx.logger.info(`sum: ${sum}`);

  outputs.sum.set(sum.toString()); // for now outputs can only of string type, but that will change in the future
  /* @end */
}

export default myFunction;
```

<ImageSpotlight
  alt="Example of a custom build config using custom JavaScript/TypeScript function."
  src="/static/images/eas-build/custom-build-function-advanced.png"
/>

> **Info** Remember to rebuild your custom function after making any changes to it.

</Step>

## Summary

- Writing custom EAS Build functions is a great way to extend the functionality of EAS Build custom builds with your own logic.
- EAS Build functions are reusable and can be used in multiple workflows.
- Using EAS Build functions is a great option for more advanced use cases that are not easy to do by writing shell scripts.
- Most of our [built-in functions](/custom-builds/schema/#built-in-eas-functions) are open-sourced and can be used as a reference for writing your own custom functions.

Check out the **example repository** for more detailed examples:

<BoxLink
  title="Custom build example repository"
  description="A custom EAS Build example that includes examples for workflows such as setting up functions, using environment variables, uploading artifacts, and more."
  Icon={GithubIcon}
  href="https://github.com/expo/eas-custom-builds-example/tree/main"
/>
