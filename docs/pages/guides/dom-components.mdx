---
title: Using React DOM in Expo
sidebar_title: DOM Components
description: Learn about rendering React DOM elements in Expo native apps.
---

import { Collapsible } from '~/ui/components/Collapsible';
import { Step } from '~/ui/components/Step';
import { Tab, Tabs } from '~/ui/components/Tabs';

Expo offers a novel approach to working with modern web code directly in a native app via the `'use dom'` directive. This enables incremental migration for an entire website to a universal app, simply moving on a per-component basis.

The Expo native runtime generally does not support using `<div>` or `<img>` tags, but you may find that you want to quickly drop in some web components. This is where DOM components come in.

## Usage

To render a web component, simply add the `'use dom'` directive to the top of a file:

```js my-component.js (web)
'use dom';

export default function MyComponent() {
  return (
    <div>
      <h1>Hello, world!</h1>
    </div>
  );
}
```

```js App.js (native)
import MyComponent from './my-component.js';

export default function App() {
  return (
    // This component is a WebView from react-native-webview.
    <MyComponent style={{ backgroundColor: 'dodgerblue' }} />
  );
}
```

## Features

- Shared bundler config across web native and webviews.
- React, TypeScript, CSS, and all other Metro features are enabled in dom components.
- Logging in the terminal.
- Fast Refresh and HMR.
- Embedded exports for offline support.
- Assets are handled the same way as in the native app.
- WebView bundles can be introspected in Expo Atlas for debugging.
- Access to all web functionality without needing a native rebuild.
- Runtime error overlay in development.

## WebView props

To pass props to the underlying WebView, add a `dom` object to the component:

```tsx my-components.tsx (web)
'use dom';

export default function MyComponent({}: { dom: import('expo/dom').DOMProps }) {
  return (
    <div>
      <h1>Hello, world!</h1>
    </div>
  );
}
```

Now you can pass [`WebView` props](https://github.com/react-native-webview/react-native-webview/blob/master/docs/Reference.md) to the dom component:

```tsx App.tsx (native)
import MyComponent from './my-component';

export default function App() {
  return (
    <MyComponent
      dom={{
        scrollEnabled: false,
      }}
    />
  );
}
```

## Native Actions

You can send type-safe native functions to DOM components by passing async functions as props to the DOM component:

```ts App.tsx (native)
import MyWebView from './my-component';

export default function App() {
  return (
    <MyWebView
      hello={(data: string) => {
        console.log('Hello', data)
      }}
    />
  );
}
```

```tsx my-component.tsx (web)
'use dom';

export default function MyComponent({ hello }: { hello: (data: string) => Promise<void> }) {
  return <p onClick={() => hello('world')}>Click me</p>;
}
```

Native actions are always asynchronous and only accept serializable arguments (i.e. no functions). This is because the data is sent over a bridge to the WebView.

Native actions can return serializable data to the WebView, this is useful for getting data back from the native side.

```tsx
getDeviceName(): Promise<string> {
  return DeviceInfo.getDeviceName();
}
```

Think of these functions like React Server Actions, but instead of living on the server they live locally in the native app and communicate with the WebView. This is a powerful way to inject truly native functionality into your WebViews.

## Marshalled props

You can also send data to the WebView through serializable props:

```tsx App.tsx (native)
export default function App() {
  return <MyComponent hello={'world'} />;
}
```

```tsx my-component.tsx (web)
'use dom';

export default function MyComponent({ hello }: { hello: string }) {
  return <p>Hello, {hello}</p>;
}
```

These props are sent over an async bridge so they won't be updated synchronously. They're passed as props to the React root component meaning they re-render the entire React tree.

## Feature detection

Because webview components are simply web components, you may find yourself needing extra qualifiers to better support libraries. You can detect if a component is running in a webview with the following:

```js
if (
  typeof window !== 'undefined' &&
  // Detect if the webview global is available.
  typeof window.ReactNativeWebView !== 'undefined'
) {
  // ...
}
```

## Debugging

By default, all `console.log` methods are extended in WebViews to forward logs to the terminal. This makes it fast and easy to see what's happening in your DOM components.

Expo also enables WebView inspection and debugging when bundling in development mode. This means you can open Safari > Develop > Simulator > `MyComponent.tsx` to see the webview's console and inspect elements.

## Manual WebViews

You can still create a manual WebView using the `WebView` component from `react-native-webview`:

```js App.js (native)
import { WebView } from 'react-native-webview';

export default function App() {
  return <WebView source={{ html: '<h1>Hello, world!</h1>' }} />;
}
```

This can be useful for rendering websites from a remote server.

## Measuring WebViews

You may want to measure the size of a DOM component and report it back to the native side. This can be done using a native action:

```tsx App.tsx (native)
import MyComponent from './my-component';
import { useState } from 'react';

export default function Route() {
  const [height, setHeight] = useState(270);
  return (
    <MyComponent
      updateSize={size => {
        if (size[1] !== height) {
          setHeight(size[1]);
        }
      }}
      dom={{
        style: { height },
      }}
    />
  );
}
```

```tsx my-component.tsx (web)
import { useEffect } from 'react';

function useSize(callback: (size: [number, number]) => void) {
  useEffect(() => {
    // Observe window size changes
    const observer = new ResizeObserver(entries => {
      for (const entry of entries) {
        const { width, height } = entry.contentRect;
        callback([width, height]);
      }
    });

    observer.observe(document.body);

    callback([document.body.clientWidth, document.body.clientHeight]);

    return () => {
      observer.disconnect();
    };
  }, [callback]);
}

export default function Route({
  onLayout,
}: {
  dom: import('expo/dom').DOMProps;
  onLayout(size: [number, number]);
}) {
  useSize(onLayout);

  return <div />;
}
```

## Architecture

Built-in DOM support only renders content as single-page applications (e.g. no SSR or SSG). This is because it's a bit simpler to work with and because you don't need browser indexing techniques in your embedded JS code.

When a module is marked with `'use dom'`, the module is replaced with a proxy reference which is imported at runtime. This feature is primarily just a number of bundler and CLI magic tricks. You can always use a WebView with the standard approach by passing raw HTML to a WebView component if you'd like.

If you import a DOM component from another webview, the component will just be one large webview. This is because web content is passed directly through and not wrapped in an iframe.

Overall, this system shares a lot of similarities with Expo's React Server Components implementation.

## Considerations

We recommend always building truly native apps using universal primitives such as `View`, `Image`, and `Text`. WebViews only support standard JavaScript which is slower to parse and startup than Hermes bytecode.

Data can only be sent between webviews and your native app via an async JSON transport system. Avoid depending on data across JS engines. Also avoid deep linking to nested URLs in webviews.

If you have a global state for sharing data this won't be available across JS engines.

While native modules in the Expo SDK can be optimized to support webviews, we haven't done this yet.

While you should avoid using WebViews for your main app, there are some reasonable uses for them. For example, WebViews are conceptually the best way to render rich text and markdown. WebViews also have very good WebGL support.

Many large apps also use WebViews for auxiliary routes such as settings pages, help pages, and other less frequently visited parts of the app.

## Limitations

- You cannot pass `children` to the webview component from the native side.
- Webviews are standalone and do not automatically share data between different instances.
- You cannot add native views to webviews. You can try to absolutely position native content on top of webviews but it may feel a bit janky.
- Function props cannot return content synchronously. They must be async.
- Webviews support both fetching from a server and reading from disk. By default, Expo's webview support embeds the web content and assets on disk to reduce version conflicts and improve performance. This can be extended in the future to support conditionally hosting components as part of our larger universal React Server Components work.

## Direction

Ultimately, universal architecture is the most exciting direction. Our extensive universal tooling is the only reason we can even offer a feature as intricate and valuable as this one.

While DOM components help with migration and moving quickly, we recommend using universal views whenever possible.
