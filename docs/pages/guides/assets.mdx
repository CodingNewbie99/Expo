---
title: Assets
description: Learn about using local and remote assets.
---

Files such as images, videos, sounds, database files for SQLite, or fonts are considered **assets**. They are not part of your project's JavaScript but are part of your app.

Your project can use two types of assets: **Local** and **Remote**. This guide will explain how to use both types of assets.

## Local assets

These assets are stored on your file system and can be imported like JavaScript modules using `require` or `import` statements.

For example, to render an image called **example.png** in **App.js**, you can directly use `require` to import the image from the project's **assets/images** directory and pass it to the `<Image>` component:

```jsx App.js
<Image source={require('./assets/images/example.png')} />
```

The bundler automatically provides a width and height for the images imported, as shown in the above example. For more information, see [Static Image Resources](https://reactnative.dev/docs/images#static-image-resources).

Libraries such as `expo-image` and `expo-file-system` work similarly to the `<Image>` component with local assets.

### How are local assets served

Local assets used this way are served over HTTP in development. They are automatically bundled into your app binary at the build time for production apps.

### Load a local asset at build time

**Note:** The `expo-asset` config plugin is only available for SDK 51 and above. If you are using an older SDK, you can load a [using the `useAssets` hook](/versions/unversioned/sdk/asset/#useassetsmoduleids).

Install the `expo-asset` library and add the config plugin to the app config file. This plugin will embed the asset file in your native project.

```json app.json
{
  "expo": {
    "plugins": [
      [
        "expo-asset",

        {
          "assets": ["./assets/images/example.png"]
        }
      ]
    ]
  }
}
```

The `assets` option takes an array of one or more asset files or directory names to link the file to the native project. The path to each file is relative to the project's root.

When you [create a new native build](/develop/development-builds/create-a-build/), you can import and use the asset in your project without using a `require` or an `import` statement.

For example, the **example.png** is linked by the above config plugin. You can directly import it into your component:

```jsx App.js
import { Image } from 'expo-image';
/* @hide ... */ /* @end */

function App() {
  return <Image source="example" />;
}
```

> **info** For more information on supported file formats used with the config plugin, see [Assets API reference](/versions/unversioned/sdk/asset/#configurable-properties).

### Load a local asset at runtime

Install the `expo-asset` library in your project. Once the installation step is complete, import the `useAssets` hook from the `expo-asset` library. The hook downloads and stores an asset locally, and after the asset is loaded, it returns a list of that asset's instances.

```jsx App.js
import { useAssets } from 'expo-asset';

export default function App() {
  const [assets, error] = useAssets([
    require('path/to/example-1.jpg'),
    require('path/to/example-2.png'),
  ]);

  return assets ? <Image source={assets[0]} /> : null;
}
```

## Remote assets

Remote assets are not bundled into binaries at build time. You can use the URL of the asset resource in your project if it is hosted remotely. For example, pass the URL to the `<Image>` component to render a remote image.

```jsx App.js
import { Image } from 'expo-image';

// ...

function App() {
  return (
    <Image source={{ uri: 'https://example.com/logo.png' }} style={{ width: 50, height: 50 }} />
  );
}
```

There is no guarantee about the availability of images served remotely using a web URL because an internet connection may not be available, or the asset might be removed.

Additionally, loading assets remotely also requires you to pass the metadata. In this example, the bundler cannot retrieve the image's metadata (width and height), and you have to pass it explicitly to the `<Image>` component. If you don't, the image will default to 0x0.

## Optimization

### Images

You can also compress images using any other online service or a tool such as:

- [`guetzli`](https://github.com/google/guetzli)

- [`pngcrush`](https://pmt.sourceforge.io/pngcrush/)

- [`optipng`](http://optipng.sourceforge.net/)

Some image optimizers are lossless. They re-encode your image to be smaller without any change or loss in the pixels displayed. When you need each pixel untouched from the original image, a lossless optimizer and a lossless image format like PNG are a good choice.

Other image optimizers are lossy. The optimized image differs from the original image. Often, lossy optimizers are more efficient because they discard visual information that reduces file size while making the image look nearly identical to humans. Tools like `imagemagick` can use comparison algorithms likeÂ [SSIM](https://en.wikipedia.org/wiki/Structural_similarity) to show how similar two images look. It's quite common for an optimized image over 95% similar to the original image to be far less than 95% of the original file size.

It's up to the developer to optimize and minify assets like GIFs, movies, or non-code and non-image assets. GIFs are a very inefficient format, and modern video codecs can produce smaller file sizes.

### Fonts

See the fonts guide for more information.

---

## Local assets

Assets stored on your file system can be imported like JavaScript modules, using `require` or `import`. For example, from **App.js**, to render an image called **example.png** that is stored within the project's **assets/images** directory you can use `require` to import the image and then pass it to the `Image` component:

```jsx App.js
<Image source={require('./assets/images/example.png')} />
```

The bundler will automatically provide a width and height for images imported this way. For more information, see [Static Image Resources](https://reactnative.dev/docs/images#static-image-resources).

Libraries like [`expo-av`](/versions/latest/sdk/video/) and [`expo-file-system`](/versions/latest/sdk/filesystem/) work similar to `Image` with local assets.

Local assets this way will be served over HTTP in development, and they will be automatically bundled into your app binary at build time.

When you publish an update to your app with [EAS Update](/eas-update/introduction/), your assets will be uploaded and served from a CDN. Any asset that is not already included in the build that receives the update will be downloaded before launching the update. When testing an app in Expo Go, assets will be downloaded as the project is running. You can load these before your app starts with the [`useAssets`](/versions/latest/sdk/asset/) hook.

## Remote assets

To render a remote image, pass the URL to the image to the `Image` component:

```jsx App.js
<Image source={{ uri: 'https://example.com/logo.png' }} />
```

No guarantee can be made about the availability of the images that you refer to with a web URL because an internet connection may not be available or the asset may have been removed. Additionally, we don't have the same amount of information about arbitrary web URLs: when your assets are available on the local filesystem, the bundler can read some metadata (for example, width and height) and pass that through to your app, so you don't need to specify a width and height. When specifying a remote web URL, you will need to explicitly specify a width and height, or it will default to 0x0. Lastly, as you will see later, caching behavior is different in both cases.

Libraries like [`expo-av`](/versions/latest/sdk/video/) and [`expo-file-system`](/versions/latest/sdk/filesystem/) work similar to `Image` with local assets.

Remote assets are not bundled into binaries at build time. They are also not considered part of an [EAS Update](/eas-update/introduction/) bundle.

## Customizing supported asset extensions

If you need to import a file type that is not recognized by Metro by default, you can modify the Metro configuration. For example, you may want to use the `.db` to import a database into your app. Read more about how to customize the asset extensions supported by Metro for Android and iOS in [Customizing Metro](/guides/customizing-metro).

## Optimization

### Images

You can compress images using tools such as [guetzli](https://github.com/google/guetzli), [pngcrush](https://pmt.sourceforge.io/pngcrush/), or [optipng](http://optipng.sourceforge.net/). [imagemin](https://github.com/imagemin/imagemin) is another program and JS library that supports plugins for various optimizers. Many online services can optimize your images for you.

Some image optimizers are lossless. This means they re-encode your image to be smaller without any change, or loss, in the pixels that are displayed. When you need each pixel to be untouched from the original image, a lossless optimizer and a lossless image format like PNG is a good choices.

Other image optimizers are lossy, which means the optimized image is different than the original image. Often, lossy optimizers are more efficient because they discard visual information that reduces file size while making the image look nearly the same to humans. Tools like `imagemagick` can use comparison algorithms like [SSIM](https://en.wikipedia.org/wiki/Structural_similarity) to give a sense of how similar two images look. It's quite common for an optimized image that is over 95% similar to the original image to be far less than 95% of the original file size!

### Fonts

As explained above, in production builds, your local assets will all be bundled and loaded from disk rather than over the network as expected for native apps, but they must be loaded over the network when previewing in development builds. On the web, the font loading problem is known by: [Flash of Unstyled Text (FOUT), Flash of Invisible Text (FOIT), and Flash of Faux Text (FOFT)](https://css-tricks.com/fout-foit-foft/).

The default behavior with [`@expo/vector-icons`](icons.mdx#icons) icons is a FOIT on the first load, and on subsequent loads, the font will be automatically cached. You may want to preload fonts during the initial loading screen with [`useFonts`](/versions/latest/sdk/font/#usefontsmap). For example:

```jsx App.js
useFonts([require('./assets/fonts/ComicSans.ttf', FontAwesome.font)]);
```
