{"version":3,"file":"useWebCameraStream.js","sourceRoot":"","sources":["../src/useWebCameraStream.ts"],"names":[],"mappings":"AAAA,wBAAwB;AACxB,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAQ/B,OAAO,KAAK,KAAK,MAAM,kBAAkB,CAAC;AAC1C,OAAO,EAAE,sBAAsB,EAAE,MAAM,gBAAgB,CAAC;AAExD,MAAM,mBAAmB,GAAG;IAC1B,WAAW;IACX,WAAW;IACX,sBAAsB;IACtB,kBAAkB;IAClB,KAAK;IACL,YAAY;IACZ,UAAU;IACV,YAAY;IACZ,WAAW;IACX,eAAe;IACf,cAAc;IACd,MAAM;CACP,CAAC;AAEF,SAAS,cAAc,CAAC,KAA8B,EAAE,QAAoB;IAC1E,KAAK,CAAC,SAAS,CAAC,GAAG,EAAE;QACnB,IAAI,KAAK,EAAE;YACT,KAAK,CAAC,gBAAgB,CAAC,gBAAgB,EAAE,GAAG,EAAE;gBAC5C,kFAAkF;gBAClF,iFAAiF;gBACjF,2EAA2E;gBAC3E,qBAAqB,CAAC,GAAG,EAAE;oBACzB,QAAQ,EAAE,CAAC;gBACb,CAAC,CAAC,CAAC;YACL,CAAC,CAAC,CAAC;SACJ;IACH,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC;AACd,CAAC;AAED,MAAM,UAAU,kBAAkB,CAChC,KAAsD,EACtD,aAAyB,EACzB,QAA6B,EAC7B,EACE,aAAa,EACb,YAAY,GAC+D;IAK7E,MAAM,gBAAgB,GAAG,KAAK,CAAC,MAAM,CAAiB,KAAK,CAAC,CAAC;IAC7D,MAAM,aAAa,GAAG,KAAK,CAAC,MAAM,CAAgB,EAAE,CAAC,CAAC;IACtD,MAAM,YAAY,GAAG,KAAK,CAAC,MAAM,CAAoB;QACnD,SAAS,EAAE,YAAY;QACvB,SAAS,EAAE,KAAK;QAChB,YAAY,EAAE,YAAY;QAC1B,IAAI,EAAE,CAAC;KACR,CAAC,CAAC;IACH,MAAM,CAAC,MAAM,EAAE,SAAS,CAAC,GAAG,KAAK,CAAC,QAAQ,CAAqB,IAAI,CAAC,CAAC;IAErE,MAAM,kBAAkB,GAAG,KAAK,CAAC,OAAO,CAAC,GAAG,EAAE;QAC5C,OAAO,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC;IAC7D,CAAC,EAAE,CAAC,MAAM,CAAC,CAAC,CAAC;IAEb,gFAAgF;IAChF,MAAM,IAAI,GAAG,KAAK,CAAC,OAAO,CAAC,GAAG,EAAE;QAC9B,IAAI,CAAC,kBAAkB,EAAE;YACvB,OAAO,IAAI,CAAC;SACb;QACD,gGAAgG;QAChG,MAAM,EAAE,UAAU,GAAG,MAAM,EAAE,GAAG,kBAAkB,CAAC;QACnD,OAAO,sBAAsB,CAAC,UAAU,CAAC,CAAC;IAC5C,CAAC,EAAE,CAAC,kBAAkB,CAAC,CAAC,CAAC;IAEzB,MAAM,oBAAoB,GAAG,KAAK,CAAC,WAAW,CAAC,KAAK,IAAiC,EAAE;QACrF,IAAI;YACF,OAAO,MAAM,KAAK,CAAC,wBAAwB,CAAC,aAAa,CAAC,CAAC;SAC5D;QAAC,OAAO,WAAW,EAAE;YACpB,IAAI,OAAO,EAAE;gBACX,OAAO,CAAC,IAAI,CAAC,wCAAwC,aAAa,IAAI,EAAE,WAAW,CAAC,CAAC;aACtF;YACD,IAAI,YAAY,EAAE;gBAChB,YAAY,CAAC,EAAE,WAAW,EAAE,CAAC,CAAC;aAC/B;YACD,OAAO,IAAI,CAAC;SACb;IACH,CAAC,EAAE,CAAC,aAAa,EAAE,YAAY,CAAC,CAAC,CAAC;IAElC,MAAM,WAAW,GAAG,KAAK,CAAC,WAAW,CAAC,KAAK,IAAsB,EAAE;QACjE,MAAM,UAAU,GAAG,MAAM,oBAAoB,EAAE,CAAC;QAChD,IAAI,KAAK,CAAC,cAAc,CAAC,UAAU,EAAE,MAAM,CAAC,EAAE;YAC5C,0CAA0C;YAC1C,yIAAyI;YACzI,uEAAuE;YACvE,OAAO,KAAK,CAAC;SACd;QAED,gFAAgF;QAChF,6DAA6D;QAC7D,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,EAAE,KAAK,UAAU,EAAE,EAAE,CAAC,EAAE;YACrE,aAAa,CAAC,OAAO,CAAC,IAAI,CAAC,UAAW,CAAC,CAAC;SACzC;QAED,4EAA4E;QAC5E,SAAS,CAAC,UAAU,CAAC,CAAC;QACtB,IAAI,aAAa,EAAE;YACjB,aAAa,EAAE,CAAC;SACjB;QACD,OAAO,KAAK,CAAC;IACf,CAAC,EAAE,CAAC,oBAAoB,EAAE,SAAS,EAAE,aAAa,EAAE,MAAM,EAAE,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC;IAEpF,KAAK,CAAC,SAAS,CAAC,GAAG,EAAE;QACnB,mDAAmD;QACnD,IAAI,gBAAgB,CAAC,OAAO,EAAE;YAC5B,OAAO;SACR;QACD,gBAAgB,CAAC,OAAO,GAAG,IAAI,CAAC;QAEhC,WAAW,EAAE;aACV,IAAI,CAAC,UAAU,CAAC,EAAE;YACjB,gBAAgB,CAAC,OAAO,GAAG,UAAU,CAAC;QACxC,CAAC,CAAC;aACD,KAAK,CAAC,GAAG,EAAE;YACV,0CAA0C;YAC1C,gBAAgB,CAAC,OAAO,GAAG,KAAK,CAAC;QACnC,CAAC,CAAC,CAAC;IACP,CAAC,EAAE,CAAC,aAAa,CAAC,CAAC,CAAC;IAEpB,yDAAyD;IACzD,KAAK,CAAC,SAAS,CAAC,GAAG,EAAE;QACnB,MAAM,OAAO,GAAsB,EAAE,CAAC;QAEtC,KAAK,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;YACvC,IAAI,CAAC,mBAAmB,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;gBACtC,SAAS;aACV;YACD,MAAM,SAAS,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC;YAChC,IAAI,SAAS,KAAK,YAAY,CAAC,OAAO,CAAC,GAAG,CAAC,EAAE;gBAC3C,OAAO,CAAC,GAAG,CAAC,GAAG,SAAS,CAAC;aAC1B;SACF;QAED,sDAAsD;QACtD,MAAM,UAAU,GAAG,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC;QAEjD,MAAM,qBAAqB,GAAG,EAAE,GAAG,YAAY,CAAC,OAAO,EAAE,GAAG,OAAO,EAAE,CAAC;QACtE,IAAI,UAAU,EAAE;YACd,KAAK,CAAC,qBAAqB,CAAC,aAAa,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC;SAC7D;QAED,YAAY,CAAC,OAAO,GAAG,qBAAqB,CAAC;IAC/C,CAAC,EAAE;QACD,QAAQ,CAAC,SAAS;QAClB,QAAQ,CAAC,SAAS;QAClB,QAAQ,CAAC,oBAAoB;QAC7B,QAAQ,CAAC,gBAAgB;QACzB,QAAQ,CAAC,GAAG;QACZ,QAAQ,CAAC,UAAU;QACnB,QAAQ,CAAC,QAAQ;QACjB,QAAQ,CAAC,UAAU;QACnB,QAAQ,CAAC,SAAS;QAClB,QAAQ,CAAC,aAAa;QACtB,QAAQ,CAAC,YAAY;QACrB,QAAQ,CAAC,IAAI;KACd,CAAC,CAAC;IAEH,KAAK,CAAC,SAAS,CAAC,GAAG,EAAE;QACnB,iCAAiC;QACjC,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE;YAClB,OAAO;SACR;QACD,KAAK,CAAC,cAAc,CAAC,KAAK,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;IAC9C,CAAC,EAAE,CAAC,KAAK,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC,CAAC;IAE5B,KAAK,CAAC,SAAS,CAAC,GAAG,EAAE;QACnB,OAAO,GAAG,EAAE;YACV,mHAAmH;YACnH,KAAK,MAAM,MAAM,IAAI,aAAa,CAAC,OAAO,EAAE;gBAC1C,0BAA0B;gBAC1B,KAAK,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC;aAC/B;YACD,IAAI,KAAK,CAAC,OAAO,EAAE;gBACjB,+BAA+B;gBAC/B,KAAK,CAAC,cAAc,CAAC,KAAK,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;aAC7C;QACH,CAAC,CAAC;IACJ,CAAC,EAAE,EAAE,CAAC,CAAC;IAEP,qCAAqC;IACrC,cAAc,CAAC,KAAK,CAAC,OAAO,EAAE,GAAG,EAAE;QACjC,KAAK,CAAC,qBAAqB,CAAC,aAAa,EAAE,MAAM,EAAE,YAAY,CAAC,OAAO,CAAC,CAAC;IAC3E,CAAC,CAAC,CAAC;IAEH,OAAO;QACL,IAAI;QACJ,kBAAkB;KACnB,CAAC;AACJ,CAAC","sourcesContent":["/* eslint-env browser */\r\nimport * as React from 'react';\r\n\r\nimport {\r\n  CameraReadyListener,\r\n  CameraType,\r\n  MountErrorListener,\r\n  WebCameraSettings,\r\n} from './Camera.types';\r\nimport * as Utils from './WebCameraUtils';\r\nimport { FacingModeToCameraType } from './WebConstants';\r\n\r\nconst VALID_SETTINGS_KEYS = [\r\n  'autoFocus',\r\n  'flashMode',\r\n  'exposureCompensation',\r\n  'colorTemperature',\r\n  'iso',\r\n  'brightness',\r\n  'contrast',\r\n  'saturation',\r\n  'sharpness',\r\n  'focusDistance',\r\n  'whiteBalance',\r\n  'zoom',\r\n];\r\n\r\nfunction useLoadedVideo(video: HTMLVideoElement | null, onLoaded: () => void) {\r\n  React.useEffect(() => {\r\n    if (video) {\r\n      video.addEventListener('loadedmetadata', () => {\r\n        // without this async block the constraints aren't properly applied to the camera,\r\n        // this means that if you were to turn on the torch and swap to the front camera,\r\n        // then swap back to the rear camera the torch setting wouldn't be applied.\r\n        requestAnimationFrame(() => {\r\n          onLoaded();\r\n        });\r\n      });\r\n    }\r\n  }, [video]);\r\n}\r\n\r\nexport function useWebCameraStream(\r\n  video: React.MutableRefObject<HTMLVideoElement | null>,\r\n  preferredType: CameraType,\r\n  settings: Record<string, any>,\r\n  {\r\n    onCameraReady,\r\n    onMountError,\r\n  }: { onCameraReady?: CameraReadyListener; onMountError?: MountErrorListener }\r\n): {\r\n  type: CameraType | null;\r\n  mediaTrackSettings: MediaTrackSettings | null;\r\n} {\r\n  const isStartingCamera = React.useRef<boolean | null>(false);\r\n  const activeStreams = React.useRef<MediaStream[]>([]);\r\n  const capabilities = React.useRef<WebCameraSettings>({\r\n    autoFocus: 'continuous',\r\n    flashMode: 'off',\r\n    whiteBalance: 'continuous',\r\n    zoom: 1,\r\n  });\r\n  const [stream, setStream] = React.useState<MediaStream | null>(null);\r\n\r\n  const mediaTrackSettings = React.useMemo(() => {\r\n    return stream ? stream.getTracks()[0].getSettings() : null;\r\n  }, [stream]);\r\n\r\n  // The actual camera type - this can be different from the incoming camera type.\r\n  const type = React.useMemo(() => {\r\n    if (!mediaTrackSettings) {\r\n      return null;\r\n    }\r\n    // On desktop no value will be returned, in this case we should assume the cameraType is 'front'\r\n    const { facingMode = 'user' } = mediaTrackSettings;\r\n    return FacingModeToCameraType[facingMode];\r\n  }, [mediaTrackSettings]);\r\n\r\n  const getStreamDeviceAsync = React.useCallback(async (): Promise<MediaStream | null> => {\r\n    try {\r\n      return await Utils.getPreferredStreamDevice(preferredType);\r\n    } catch (nativeEvent) {\r\n      if (__DEV__) {\r\n        console.warn(`Error requesting UserMedia for type \"${preferredType}\":`, nativeEvent);\r\n      }\r\n      if (onMountError) {\r\n        onMountError({ nativeEvent });\r\n      }\r\n      return null;\r\n    }\r\n  }, [preferredType, onMountError]);\r\n\r\n  const resumeAsync = React.useCallback(async (): Promise<boolean> => {\r\n    const nextStream = await getStreamDeviceAsync();\r\n    if (Utils.compareStreams(nextStream, stream)) {\r\n      // Do nothing if the streams are the same.\r\n      // This happens when the device only supports one camera (i.e. desktop) and the mode was toggled between front/back while already active.\r\n      // Without this check there is a screen flash while the video switches.\r\n      return false;\r\n    }\r\n\r\n    // Save a history of all active streams (usually 2+) so we can close them later.\r\n    // Keeping them open makes swapping camera types much faster.\r\n    if (!activeStreams.current.some(value => value.id === nextStream?.id)) {\r\n      activeStreams.current.push(nextStream!);\r\n    }\r\n\r\n    // Set the new stream -> update the video, settings, and actual camera type.\r\n    setStream(nextStream);\r\n    if (onCameraReady) {\r\n      onCameraReady();\r\n    }\r\n    return false;\r\n  }, [getStreamDeviceAsync, setStream, onCameraReady, stream, activeStreams.current]);\r\n\r\n  React.useEffect(() => {\r\n    // Restart the camera and guard concurrent actions.\r\n    if (isStartingCamera.current) {\r\n      return;\r\n    }\r\n    isStartingCamera.current = true;\r\n\r\n    resumeAsync()\r\n      .then(isStarting => {\r\n        isStartingCamera.current = isStarting;\r\n      })\r\n      .catch(() => {\r\n        // ensure the camera can be started again.\r\n        isStartingCamera.current = false;\r\n      });\r\n  }, [preferredType]);\r\n\r\n  // Update the native camera with any custom capabilities.\r\n  React.useEffect(() => {\r\n    const changes: WebCameraSettings = {};\r\n\r\n    for (const key of Object.keys(settings)) {\r\n      if (!VALID_SETTINGS_KEYS.includes(key)) {\r\n        continue;\r\n      }\r\n      const nextValue = settings[key];\r\n      if (nextValue !== capabilities.current[key]) {\r\n        changes[key] = nextValue;\r\n      }\r\n    }\r\n\r\n    // Only update the native camera if changes were found\r\n    const hasChanges = !!Object.keys(changes).length;\r\n\r\n    const nextWebCameraSettings = { ...capabilities.current, ...changes };\r\n    if (hasChanges) {\r\n      Utils.syncTrackCapabilities(preferredType, stream, changes);\r\n    }\r\n\r\n    capabilities.current = nextWebCameraSettings;\r\n  }, [\r\n    settings.autoFocus,\r\n    settings.flashMode,\r\n    settings.exposureCompensation,\r\n    settings.colorTemperature,\r\n    settings.iso,\r\n    settings.brightness,\r\n    settings.contrast,\r\n    settings.saturation,\r\n    settings.sharpness,\r\n    settings.focusDistance,\r\n    settings.whiteBalance,\r\n    settings.zoom,\r\n  ]);\r\n\r\n  React.useEffect(() => {\r\n    // set or unset the video source.\r\n    if (!video.current) {\r\n      return;\r\n    }\r\n    Utils.setVideoSource(video.current, stream);\r\n  }, [video.current, stream]);\r\n\r\n  React.useEffect(() => {\r\n    return () => {\r\n      // Clean up on dismount, this is important for making sure the camera light goes off when the component is removed.\r\n      for (const stream of activeStreams.current) {\r\n        // Close all open streams.\r\n        Utils.stopMediaStream(stream);\r\n      }\r\n      if (video.current) {\r\n        // Invalidate the video source.\r\n        Utils.setVideoSource(video.current, stream);\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  // Update props when the video loads.\r\n  useLoadedVideo(video.current, () => {\r\n    Utils.syncTrackCapabilities(preferredType, stream, capabilities.current);\r\n  });\r\n\r\n  return {\r\n    type,\r\n    mediaTrackSettings,\r\n  };\r\n}\r\n"]}