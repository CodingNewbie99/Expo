{"version":3,"file":"TextDecoder.js","sourceRoot":"","sources":["../../src/winter/TextDecoder.ts"],"names":[],"mappings":"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","sourcesContent":["// A fork of text-encoding but with only UTF-8 decoder.\n// `TextEncoder` is in Hermes and we only need utf-8 decoder for React Server Components.\n//\n// https://github.com/inexorabletash/text-encoding/blob/3f330964c0e97e1ed344c2a3e963f4598610a7ad/lib/encoding.js#L1\n\n/**\n * Checks if a number is within a specified range.\n * @param a The number to test.\n * @param min The minimum value in the range, inclusive.\n * @param max The maximum value in the range, inclusive.\n * @returns `true` if a passed number is within the specified range.\n */\nfunction inRange(a: number, min: number, max: number): boolean {\n  return min <= a && a <= max;\n}\n\n/**\n * Converts an array of code points to a string.\n * @param codePoints Array of code points.\n * @returns The string representation of given array.\n */\nfunction codePointsToString(codePoints: number[]): string {\n  let s = '';\n  for (let i = 0; i < codePoints.length; ++i) {\n    let cp = codePoints[i];\n    if (cp <= 0xffff) {\n      s += String.fromCharCode(cp);\n    } else {\n      cp -= 0x10000;\n      s += String.fromCharCode((cp >> 10) + 0xd800, (cp & 0x3ff) + 0xdc00);\n    }\n  }\n  return s;\n}\n\nfunction normalizeBytes(input?: ArrayBuffer | DataView): Uint8Array {\n  if (typeof input === 'object' && input instanceof ArrayBuffer) {\n    return new Uint8Array(input);\n  } else if (\n    typeof input === 'object' &&\n    'buffer' in input &&\n    input.buffer instanceof ArrayBuffer\n  ) {\n    return new Uint8Array(input.buffer, input.byteOffset, input.byteLength);\n  }\n  return new Uint8Array(0);\n}\n\n/**\n * End-of-stream is a special token that signifies no more tokens\n * are in the stream.\n */\nconst END_OF_STREAM = -1;\n\nconst FINISHED = -1;\n\n/**\n * A stream represents an ordered sequence of tokens.\n *\n * @constructor\n * @param {!(number[]|Uint8Array)} tokens Array of tokens that provide the stream.\n */\nclass Stream {\n  private tokens: number[];\n\n  constructor(tokens: number[] | Uint8Array) {\n    this.tokens = Array.prototype.slice.call(tokens);\n    // Reversed as push/pop is more efficient than shift/unshift.\n    this.tokens.reverse();\n  }\n\n  /**\n   * @return {boolean} True if end-of-stream has been hit.\n   */\n  endOfStream(): boolean {\n    return !this.tokens.length;\n  }\n\n  /**\n   * When a token is read from a stream, the first token in the\n   * stream must be returned and subsequently removed, and\n   * end-of-stream must be returned otherwise.\n   *\n   * @return {number} Get the next token from the stream, or\n   * end_of_stream.\n   */\n  read(): number {\n    if (!this.tokens.length) return END_OF_STREAM;\n    return this.tokens.pop()!;\n  }\n\n  /**\n   * When one or more tokens are prepended to a stream, those tokens\n   * must be inserted, in given order, before the first token in the\n   * stream.\n   *\n   * @param token The token(s) to prepend to the stream.\n   */\n  prepend(token: number | number[]): void {\n    if (Array.isArray(token)) {\n      while (token.length) this.tokens.push(token.pop()!);\n    } else {\n      this.tokens.push(token);\n    }\n  }\n\n  /**\n   * When one or more tokens are pushed to a stream, those tokens\n   * must be inserted, in given order, after the last token in the\n   * stream.\n   *\n   * @param token The tokens(s) to push to the stream.\n   */\n  push(token: number | number[]): void {\n    if (Array.isArray(token)) {\n      while (token.length) this.tokens.unshift(token.shift()!);\n    } else {\n      this.tokens.unshift(token);\n    }\n  }\n}\n\nfunction decoderError(fatal: boolean, opt_code_point?: number) {\n  if (fatal) throw TypeError('Decoder error');\n  return opt_code_point || 0xfffd;\n}\n\ninterface Encoding {\n  name: string;\n  labels: string[];\n}\n\nconst LABEL_ENCODING_MAP: { [key: string]: Encoding } = {};\n\nfunction getEncoding(label: string): Encoding | null {\n  label = label.trim().toLowerCase();\n  if (label in LABEL_ENCODING_MAP) {\n    return LABEL_ENCODING_MAP[label];\n  }\n  return null;\n}\n\n/** [Encodings table](https://encoding.spec.whatwg.org/encodings.json) (Incomplete as we only need TextDecoder utf8 in Expo RSC. A more complete implementation should be added to Hermes as native code.) */\nconst ENCODING_MAP: { heading: string; encodings: Encoding[] }[] = [\n  {\n    encodings: [\n      {\n        labels: [\n          'unicode-1-1-utf-8',\n          'unicode11utf8',\n          'unicode20utf8',\n          'utf-8',\n          'utf8',\n          'x-unicode20utf8',\n        ],\n        name: 'UTF-8',\n      },\n    ],\n    heading: 'The Encoding',\n  },\n];\n\nENCODING_MAP.forEach((category) => {\n  category.encodings.forEach((encoding) => {\n    encoding.labels.forEach((label) => {\n      LABEL_ENCODING_MAP[label] = encoding;\n    });\n  });\n});\n\n// Registry of of encoder/decoder factories, by encoding name.\nconst DECODERS: { [key: string]: (options: { fatal: boolean }) => UTF8Decoder } = {\n  'UTF-8': (options) => new UTF8Decoder(options),\n};\n\n// 9.1.1 utf-8 decoder\n\ninterface Decoder {\n  handler: (stream: Stream, bite: number) => number | number[] | null | -1;\n}\n\nclass UTF8Decoder implements Decoder {\n  // utf-8's decoder's has an associated utf-8 code point, utf-8\n  // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8\n  // lower boundary (initially 0x80), and a utf-8 upper boundary\n  // (initially 0xBF).\n  private utf8CodePoint = 0;\n  private utf8BytesSeen = 0;\n  private utf8BytesNeeded = 0;\n  private utf8LowerBoundary = 0x80;\n  private utf8UpperBoundary = 0xbf;\n  constructor(private options: { fatal: boolean }) {}\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  handler(stream: Stream, bite: number): number | null | -1 {\n    // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,\n    // set utf-8 bytes needed to 0 and return error.\n    if (bite === END_OF_STREAM && this.utf8BytesNeeded !== 0) {\n      this.utf8BytesNeeded = 0;\n      return decoderError(this.options.fatal);\n    }\n\n    // 2. If byte is end-of-stream, return finished.\n    if (bite === END_OF_STREAM) return FINISHED;\n\n    // 3. If utf-8 bytes needed is 0, based on byte:\n    if (this.utf8BytesNeeded === 0) {\n      // 0x00 to 0x7F\n      if (inRange(bite, 0x00, 0x7f)) {\n        // Return a code point whose value is byte.\n        return bite;\n      }\n\n      // 0xC2 to 0xDF\n      else if (inRange(bite, 0xc2, 0xdf)) {\n        // 1. Set utf-8 bytes needed to 1.\n        this.utf8BytesNeeded = 1;\n\n        // 2. Set UTF-8 code point to byte & 0x1F.\n        this.utf8CodePoint = bite & 0x1f;\n      }\n\n      // 0xE0 to 0xEF\n      else if (inRange(bite, 0xe0, 0xef)) {\n        // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.\n        if (bite === 0xe0) this.utf8LowerBoundary = 0xa0;\n        // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.\n        if (bite === 0xed) this.utf8UpperBoundary = 0x9f;\n        // 3. Set utf-8 bytes needed to 2.\n        this.utf8BytesNeeded = 2;\n        // 4. Set UTF-8 code point to byte & 0xF.\n        this.utf8CodePoint = bite & 0xf;\n      }\n\n      // 0xF0 to 0xF4\n      else if (inRange(bite, 0xf0, 0xf4)) {\n        // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.\n        if (bite === 0xf0) this.utf8LowerBoundary = 0x90;\n        // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.\n        if (bite === 0xf4) this.utf8UpperBoundary = 0x8f;\n        // 3. Set utf-8 bytes needed to 3.\n        this.utf8BytesNeeded = 3;\n        // 4. Set UTF-8 code point to byte & 0x7.\n        this.utf8CodePoint = bite & 0x7;\n      }\n\n      // Otherwise\n      else {\n        // Return error.\n        return decoderError(this.options.fatal);\n      }\n\n      // Return continue.\n      return null;\n    }\n\n    // 4. If byte is not in the range utf-8 lower boundary to utf-8\n    // upper boundary, inclusive, run these substeps:\n    if (!inRange(bite, this.utf8LowerBoundary, this.utf8UpperBoundary)) {\n      // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8\n      // bytes seen to 0, set utf-8 lower boundary to 0x80, and set\n      // utf-8 upper boundary to 0xBF.\n      this.utf8CodePoint = 0;\n      this.utf8BytesNeeded = 0;\n      this.utf8BytesSeen = 0;\n      this.utf8LowerBoundary = 0x80;\n      this.utf8UpperBoundary = 0xbf;\n\n      // 2. Prepend byte to stream.\n      stream.prepend(bite);\n\n      // 3. Return error.\n      return decoderError(this.options.fatal);\n    }\n\n    // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary\n    // to 0xBF.\n    this.utf8LowerBoundary = 0x80;\n    this.utf8UpperBoundary = 0xbf;\n\n    // 6. Set UTF-8 code point to (UTF-8 code point << 6) | (byte &\n    // 0x3F)\n    this.utf8CodePoint = (this.utf8CodePoint << 6) | (bite & 0x3f);\n\n    // 7. Increase utf-8 bytes seen by one.\n    this.utf8BytesSeen += 1;\n\n    // 8. If utf-8 bytes seen is not equal to utf-8 bytes needed,\n    // continue.\n    if (this.utf8BytesSeen !== this.utf8BytesNeeded) return null;\n\n    // 9. Let code point be utf-8 code point.\n    const code_point = this.utf8CodePoint;\n\n    // 10. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes\n    // seen to 0.\n    this.utf8CodePoint = 0;\n    this.utf8BytesNeeded = 0;\n    this.utf8BytesSeen = 0;\n\n    // 11. Return a code point whose value is code point.\n    return code_point;\n  }\n}\n\n// 8.1 Interface TextDecoder\n// @docsMissing\nexport class TextDecoder {\n  private _encoding: Encoding | null;\n  private _ignoreBOM: boolean;\n  private _errorMode: string;\n  private _BOMseen: boolean = false;\n  private _doNotFlush: boolean = false;\n  private _decoder: UTF8Decoder | null = null;\n\n  constructor(\n    label: string = 'utf-8',\n    options: {\n      fatal?: boolean;\n      ignoreBOM?: boolean;\n    } = {}\n  ) {\n    if (options != null && typeof options !== 'object') {\n      throw new TypeError(\n        'Second argument of TextDecoder must be undefined or an object, e.g. { fatal: true }'\n      );\n    }\n\n    const normalizedLabel = String(label).trim().toLowerCase();\n    const encoding = getEncoding(normalizedLabel);\n    if (encoding === null || encoding.name === 'replacement') {\n      throw new RangeError(`Unknown encoding: ${label} (normalized: ${normalizedLabel})`);\n    }\n\n    if (!DECODERS[encoding.name]) {\n      throw new Error(`Decoder not present: ${encoding.name}`);\n    }\n\n    this._encoding = encoding;\n    this._ignoreBOM = !!options.ignoreBOM;\n    this._errorMode = options.fatal ? 'fatal' : 'replacement';\n  }\n\n  // Getter methods for encoding, fatal, and ignoreBOM\n  get encoding(): string {\n    return this._encoding?.name.toLowerCase() ?? '';\n  }\n\n  get fatal(): boolean {\n    return this._errorMode === 'fatal';\n  }\n\n  get ignoreBOM(): boolean {\n    return this._ignoreBOM;\n  }\n\n  decode(input?: ArrayBuffer | DataView, options: { stream?: boolean } = {}): string {\n    const bytes = normalizeBytes(input);\n\n    // 1. If the do not flush flag is unset, set decoder to a new\n    // encoding's decoder, set stream to a new stream, and unset the\n    // BOM seen flag.\n    if (!this._doNotFlush) {\n      this._decoder = DECODERS[this._encoding!.name]({\n        fatal: this.fatal,\n      });\n      this._BOMseen = false;\n    }\n\n    // 2. If options's stream is true, set the do not flush flag, and\n    // unset the do not flush flag otherwise.\n    this._doNotFlush = Boolean(options['stream']);\n\n    // 3. If input is given, push a copy of input to stream.\n    // TODO: Align with spec algorithm - maintain stream on instance.\n    const input_stream = new Stream(bytes);\n\n    // 4. Let output be a new stream.\n    const output: number[] = [];\n\n    while (true) {\n      const token = input_stream.read();\n\n      if (token === END_OF_STREAM) break;\n\n      const result = this._decoder!.handler(input_stream, token);\n\n      if (result === FINISHED) break;\n\n      if (result !== null) {\n        output.push(result);\n      }\n    }\n\n    if (!this._doNotFlush) {\n      do {\n        const result = this._decoder!.handler(input_stream, input_stream.read());\n        if (result === FINISHED) break;\n        if (result === null) continue;\n        if (Array.isArray(result)) output.push(...result);\n        else output.push(result);\n      } while (!input_stream.endOfStream());\n      this._decoder = null;\n    }\n\n    return this.serializeStream(output);\n  }\n\n  // serializeStream method for converting code points to a string\n  private serializeStream(stream: number[]): string {\n    if (this._encoding!.name === 'UTF-8') {\n      if (!this._ignoreBOM && !this._BOMseen && stream[0] === 0xfeff) {\n        // If BOM is detected at the start of the stream and we're not ignoring it\n        this._BOMseen = true;\n        stream.shift(); // Remove the BOM\n      } else if (stream.length > 0) {\n        this._BOMseen = true;\n      }\n    }\n\n    // Convert the stream of code points to a string\n    return codePointsToString(stream);\n  }\n}\n"]}