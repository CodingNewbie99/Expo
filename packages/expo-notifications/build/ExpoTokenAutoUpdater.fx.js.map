{"version":3,"file":"ExpoTokenAutoUpdater.fx.js","sourceRoot":"","sources":["../src/ExpoTokenAutoUpdater.fx.ts"],"names":[],"mappings":"AAEA,OAAO,sBAAsB,MAAM,0BAA0B,CAAC;AAC9D,OAAO,EAAE,oBAAoB,EAAE,MAAM,gBAAgB,CAAC;AAEtD,OAAO,qBAAqB,MAAM,yBAAyB,CAAC;AAY5D;;;GAGG;AACH,KAAK,UAAU,6BAA6B,CAAC,KAAsB;IACjE,MAAM,qBAAqB,CAAC;QAC1B,GAAG,kBAAkB;QACrB,eAAe,EAAE,KAAK;KACvB,CAAC,CAAC;AACL,CAAC;AAED,sBAAsB;AACtB,IAAI,kBAAkB,GAAwB,IAAI,CAAC;AAEnD,iFAAiF;AACjF,sBAAsB,CAAC,qBAAqB,EAAE,EAAE;KAC7C,IAAI,CAAC,KAAK,EAAC,4BAA4B,EAAC,EAAE;IACzC,yDAAyD;IACzD,MAAM,sBAAsB,GAAG,MAAM,CAAC,IAAI,CAAC,4BAA4B,CAAC;SACrE,GAAG,CAAC,uBAAuB,CAAC,EAAE;QAC7B,IAAI;YACF,OAAO,IAAI,CAAC,KAAK,CAAC,uBAAuB,CAAC,CAAC;SAC5C;QAAC,OAAO,CAAC,EAAE;YACV,OAAO,CAAC,IAAI,CACV,qGAAqG,EACrG,uBAAuB,EACvB,CAAC,CACF,CAAC;SACH;IACH,CAAC,CAAC;SACD,MAAM,CAAC,YAAY,CAAC,EAAE,CAAC,YAAY,CAAC,CAAC;IAExC,mEAAmE;IACnE,IAAI,sBAAsB,CAAC,MAAM,GAAG,CAAC,EAAE;QACrC,MAAM,6BAA6B,CACjC,sBAAsB,CAAC,sBAAsB,CAAC,MAAM,GAAG,CAAC,CAAC,CAC1D,CAAC;KACH;AACH,CAAC,CAAC;KACD,KAAK,CAAC,KAAK,CAAC,EAAE,CACb,OAAO,CAAC,IAAI,CACV,sGAAsG,EACtG,KAAK,CACN,CACF,CAAC;AAEJ,IAAI,qBAAqB,GAAwB,IAAI,CAAC;AAEtD;;;;GAIG;AACH,MAAM,CAAC,KAAK,UAAU,6BAA6B,CAAC,YAA0B;IAC5E,0EAA0E;IAC1E,mEAAmE;IACnE,IAAI;QACF,MAAM,sBAAsB,CAAC,oBAAoB,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,kBAAkB,CAAC,EAAE,KAAK,CAAC,CAAC;KAChG;IAAC,OAAO,CAAC,EAAE;QACV,OAAO,CAAC,IAAI,CACV,6GAA6G,EAC7G,CAAC,CACF,CAAC;KACH;IAED,2CAA2C;IAC3C,kBAAkB,GAAG,YAAY,CAAC;IAElC,oFAAoF;IACpF,IAAI,CAAC,qBAAqB,EAAE;QAC1B,iEAAiE;QACjE,qBAAqB,GAAG,oBAAoB,CAAC,6BAA6B,CAAC,CAAC;KAC7E;IAED,wEAAwE;IACxE,MAAM,sBAAsB,CAAC,oBAAoB,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,EAAE,IAAI,CAAC,CAAC;AAC1F,CAAC","sourcesContent":["import { Subscription } from '@unimodules/core';\n\nimport InstallationIdProvider from './InstallationIdProvider';\nimport { addPushTokenListener } from './TokenEmitter';\nimport { DevicePushToken } from './Tokens.types';\nimport getExpoPushTokenAsync from './getExpoPushTokenAsync';\n\n// Possible getExpoPushTokenAsync options overrides\ntype Registration = {\n  url: string;\n  type?: string;\n  deviceId?: string;\n  development?: boolean;\n  experienceId?: string;\n  applicationId?: string;\n};\n\n/**\n * Informs active registrations of a given new device push token\n * @param token New device push token to inform registration of\n */\nasync function updateActiveRegistrationAsync(token: DevicePushToken) {\n  await getExpoPushTokenAsync({\n    ...activeRegistration,\n    devicePushToken: token,\n  });\n}\n\n// Module-wide storage\nlet activeRegistration: Registration | null = null;\n\n// On startup fetch all active registrations and add them to the session storage.\nInstallationIdProvider.getRegistrationsAsync?.()\n  .then(async persistedRegistrationsObject => {\n    // Parse all registrations and return only the valid ones\n    const persistedRegistrations = Object.keys(persistedRegistrationsObject)\n      .map(stringifiedRegistration => {\n        try {\n          return JSON.parse(stringifiedRegistration);\n        } catch (e) {\n          console.warn(\n            '[expo-notifications] Could not have parsed the registration information for automatic token update.',\n            stringifiedRegistration,\n            e\n          );\n        }\n      })\n      .filter(registration => registration);\n\n    // Set auto token registration only for the last valid registration\n    if (persistedRegistrations.length > 0) {\n      await setAutoTokenRegistrationAsync(\n        persistedRegistrations[persistedRegistrations.length - 1]\n      );\n    }\n  })\n  .catch(error =>\n    console.warn(\n      '[expo-notifications] Could not have fetched the registration information for automatic token update.',\n      error\n    )\n  );\n\nlet pushTokenSubscription: Subscription | null = null;\n\n/**\n * Sets the registration information to the persisted storage so that the device push token\n * gets pushed to the given registration endpoint, overridding previous registrations\n * @param registration Registration endpoint to inform of new tokens\n */\nexport async function setAutoTokenRegistrationAsync(registration: Registration) {\n  // Remove all other registrations (we use allSettled because we don't care\n  // if the `set` succeeds there's nothing we can do about rejection)\n  try {\n    await InstallationIdProvider.setRegistrationAsync?.(JSON.stringify(activeRegistration), false);\n  } catch (e) {\n    console.warn(\n      '[expo-notifications] Could not have removed the active registration information for automatic token update.',\n      e\n    );\n  }\n\n  // Add registration to this session storage\n  activeRegistration = registration;\n\n  // If the subscription has not been set up yet (no previous persisted registrations)\n  if (!pushTokenSubscription) {\n    // set it up so all registrations get latest push token received.\n    pushTokenSubscription = addPushTokenListener(updateActiveRegistrationAsync);\n  }\n\n  // Ensure on next session the registration will get considered as active\n  await InstallationIdProvider.setRegistrationAsync?.(JSON.stringify(registration), true);\n}\n"]}