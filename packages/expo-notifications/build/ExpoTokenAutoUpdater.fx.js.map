{"version":3,"file":"ExpoTokenAutoUpdater.fx.js","sourceRoot":"","sources":["../src/ExpoTokenAutoUpdater.fx.ts"],"names":[],"mappings":"AAEA,OAAO,sBAAsB,MAAM,0BAA0B,CAAC;AAC9D,OAAO,EAAE,oBAAoB,EAAE,MAAM,gBAAgB,CAAC;AAEtD,OAAO,qBAAqB,MAAM,yBAAyB,CAAC;AAY5D;;;GAGG;AACH,KAAK,UAAU,wBAAwB,CAAC,KAAsB;IAC5D,OAAO,OAAO,CAAC,UAAU,CACvB,aAAa,CAAC,GAAG,CAAC,YAAY,CAAC,EAAE,CAC/B,qBAAqB,CAAC;QACpB,GAAG,YAAY;QACf,eAAe,EAAE,KAAK;KACvB,CAAC,CACH,CACF,CAAC;AACJ,CAAC;AAED,sBAAsB;AACtB,MAAM,aAAa,GAAmB,EAAE,CAAC;AAEzC,iFAAiF;AACjF,sBAAsB,CAAC,qBAAqB,EAAE,EAAE;KAC7C,IAAI,CAAC,KAAK,EAAC,sBAAsB,EAAC,EAAE;IACnC,KAAK,MAAM,uBAAuB,IAAI,MAAM,CAAC,IAAI,CAAC,sBAAsB,CAAC,EAAE;QACzE,yDAAyD;QACzD,IAAI;YACF,MAAM,6BAA6B,CAAC,IAAI,CAAC,KAAK,CAAC,uBAAuB,CAAC,CAAC,CAAC;SAC1E;QAAC,OAAO,CAAC,EAAE;YACV,OAAO,CAAC,IAAI,CACV,qGAAqG,EACrG,uBAAuB,EACvB,CAAC,CACF,CAAC;SACH;KACF;AACH,CAAC,CAAC;KACD,KAAK,CAAC,KAAK,CAAC,EAAE,CACb,OAAO,CAAC,IAAI,CACV,sGAAsG,EACtG,KAAK,CACN,CACF,CAAC;AAEJ,IAAI,qBAAqB,GAAwB,IAAI,CAAC;AAEtD;;;;GAIG;AACH,MAAM,CAAC,KAAK,UAAU,6BAA6B,CAAC,YAA0B;IAC5E,2CAA2C;IAC3C,aAAa,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;IAEjC,oFAAoF;IACpF,IAAI,CAAC,qBAAqB,EAAE;QAC1B,iEAAiE;QACjE,qBAAqB,GAAG,oBAAoB,CAAC,wBAAwB,CAAC,CAAC;KACxE;IAED,wEAAwE;IACxE,MAAM,sBAAsB,CAAC,oBAAoB,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,EAAE,IAAI,CAAC,CAAC;AAC1F,CAAC","sourcesContent":["import { Subscription } from '@unimodules/core';\n\nimport InstallationIdProvider from './InstallationIdProvider';\nimport { addPushTokenListener } from './TokenEmitter';\nimport { DevicePushToken } from './Tokens.types';\nimport getExpoPushTokenAsync from './getExpoPushTokenAsync';\n\n// Possible getExpoPushTokenAsync options overrides\ntype Registration = {\n  url: string;\n  type?: string;\n  deviceId?: string;\n  development?: boolean;\n  experienceId?: string;\n  applicationId?: string;\n};\n\n/**\n * Informs all registrations of a given new device push token\n * @param token New device push token to inform all registrations of\n */\nasync function updateRegistrationsAsync(token: DevicePushToken) {\n  return Promise.allSettled(\n    registrations.map(registration =>\n      getExpoPushTokenAsync({\n        ...registration,\n        devicePushToken: token,\n      })\n    )\n  );\n}\n\n// Module-wide storage\nconst registrations: Registration[] = [];\n\n// On startup fetch all active registrations and add them to the session storage.\nInstallationIdProvider.getRegistrationsAsync?.()\n  .then(async persistedRegistrations => {\n    for (const stringifiedRegistration of Object.keys(persistedRegistrations)) {\n      // One registration fail shouldn't fail all registrations\n      try {\n        await addAutoTokenRegistrationAsync(JSON.parse(stringifiedRegistration));\n      } catch (e) {\n        console.warn(\n          '[expo-notifications] Could not have parsed the registration information for automatic token update.',\n          stringifiedRegistration,\n          e\n        );\n      }\n    }\n  })\n  .catch(error =>\n    console.warn(\n      '[expo-notifications] Could not have fetched the registration information for automatic token update.',\n      error\n    )\n  );\n\nlet pushTokenSubscription: Subscription | null = null;\n\n/**\n * Adds the registration information to the persisted storage so that the device push token\n * gets pushed to the given registration endpoint\n * @param registration Registration endpoint to inform of new tokens\n */\nexport async function addAutoTokenRegistrationAsync(registration: Registration) {\n  // Add registration to this session storage\n  registrations.push(registration);\n\n  // If the subscription has not been set up yet (no previous persisted registrations)\n  if (!pushTokenSubscription) {\n    // set it up so all registrations get latest push token received.\n    pushTokenSubscription = addPushTokenListener(updateRegistrationsAsync);\n  }\n\n  // Ensure on next session the registration will get considered as active\n  await InstallationIdProvider.setRegistrationAsync?.(JSON.stringify(registration), true);\n}\n"]}