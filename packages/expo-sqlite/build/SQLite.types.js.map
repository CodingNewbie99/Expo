{"version":3,"file":"SQLite.types.js","sourceRoot":"","sources":["../src/SQLite.types.ts"],"names":[],"mappings":"AAAA,8BAA8B;AAC9B,6CAA6C;AAC7C,iEAAiE;AACjE,kEAAkE","sourcesContent":["// Type definitions for websql\n// Project: http://www.w3.org/TR/webdatabase/\n// Definitions by: TeamworkGuy2 <https://github.com/TeamworkGuy2>\n// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped\n\n// W3C spec: http://www.w3.org/TR/webdatabase/#database\n// Spec revision: 2010-11-18\n// NOTE: the W3C websql spec has been deprecated\n\n//[Callback = FunctionOnly, NoInterfaceObject]\nexport interface DatabaseCallback {\n  /*handleEvent*/ (database: Database): void;\n}\n\n/** 4.3 Asynchronous database API - The transaction() and readTransaction() methods takes\n * one to three arguments. When called, these methods must immediately return and then\n * asynchronously run the transaction steps with the transaction callback being the\n * first argument, the error callback being the second argument, if any, the success\n * callback being the third argument, if any, and with no preflight operation or\n * postflight operation\n */\nexport interface Database {\n  /*readonly/const*/ version: string;\n\n  transaction(\n    callback: SQLTransactionCallback,\n    errorCallback?: SQLTransactionErrorCallback,\n    successCallback?: SQLVoidCallback\n  ): void;\n\n  readTransaction(\n    callback: SQLTransactionCallback,\n    errorCallback?: SQLTransactionErrorCallback,\n    successCallback?: SQLVoidCallback\n  ): void;\n\n  /** The changeVersion() method allows scripts to atomically verify the version number and change\n   * it at the same time as doing a schema update. When the method is invoked, it must immediately\n   * return, and then asynchronously run the transaction steps with the transaction callback being\n   * the third argument, the error callback being the fourth argument, the success callback being\n   * the fifth argument\n   */\n  changeVersion(\n    oldVersion: string,\n    newVersion: string,\n    callback?: SQLTransactionCallback,\n    errorCallback?: SQLTransactionErrorCallback,\n    successCallback?: SQLVoidCallback\n  ): void;\n}\n\n//[Callback = FunctionOnly, NoInterfaceObject]\nexport interface SQLVoidCallback {\n  /*handleEvent*/ (): void;\n}\n\n//[Callback = FunctionOnly, NoInterfaceObject]\nexport interface SQLTransactionCallback {\n  /*handleEvent*/ (transaction: SQLTransaction): void;\n}\n\n//[Callback = FunctionOnly, NoInterfaceObject]\nexport interface SQLTransactionErrorCallback {\n  /*handleEvent*/ (error: SQLError): void;\n}\n\n/** 4.3.1 Executing SQL statements\n */\nexport interface SQLTransaction {\n  executeSql(\n    sqlStatement: string,\n    args?: Array<any>,\n    callback?: SQLStatementCallback,\n    errorCallback?: SQLStatementErrorCallback\n  ): void;\n}\n\n//[Callback = FunctionOnly, NoInterfaceObject]\nexport interface SQLStatementCallback {\n  /*handleEvent*/ (transaction: SQLTransaction, resultSet: SQLResultSet): void;\n}\n\n//[Callback = FunctionOnly, NoInterfaceObject]\nexport interface SQLStatementErrorCallback {\n  /*handleEvent*/ (transaction: SQLTransaction, error: SQLError): boolean;\n}\n\n/** 4.4 Synchronous database API\n */\nexport interface DatabaseSync {\n  /*readonly/const*/ version: string;\n\n  transaction(callback: SQLTransactionSyncCallback): void;\n\n  readTransaction(callback: SQLTransactionSyncCallback): void;\n\n  changeVersion(oldVersion: string, newVersion: string, callback: SQLTransactionSyncCallback): void;\n}\n\n//[Callback = FunctionOnly, NoInterfaceObject]\nexport interface SQLTransactionSyncCallback {\n  /*handleEvent*/ (transaction: SQLTransactionSync): void;\n}\n\n/** 4.4.1 Executing SQL statements\n */\nexport interface SQLTransactionSync {\n  executeSql(sqlStatement: string, args?: Array<any>): SQLResultSet;\n}\n\n/** 4.5 Database query results\n * The insertId attribute must return the row ID of the row that the SQLResultSet\n * object's SQL statement inserted into the database, if the statement inserted a row.\n * If the statement inserted multiple rows, the ID of the last row must be the one returned.\n * If the statement did not insert a row, then the attribute must instead raise an INVALID_ACCESS_ERR exception.\n *\n * The rowsAffected attribute must return the number of rows that were changed by the SQL statement.\n * If the statement did not affected any rows, then the attribute must return zero.\n * For \"SELECT\" statements, this returns zero (querying the database doesn't affect any rows).\n *\n * The rows attribute must return a SQLResultSetRowList representing the rows returned,\n * in the order returned by the database. The same object must be returned each time.\n * If no rows were returned, then the object will be empty (its length will be zero)\n */\nexport interface SQLResultSet {\n  insertId: number;\n  rowsAffected: number;\n  rows: SQLResultSetRowList;\n}\n\n/** SQLResultSetRowList objects have a length attribute that must return the number of\n * rows it represents (the number of rows returned by the database). This is the length.\n * Fetching the length might be expensive, and authors are thus encouraged to avoid using\n * it (or enumerating over the object, which implicitly uses it) where possible.\n * The object's supported property indices are the numbers in the range zero to length-1,\n * unless the length is zero, in which case there are no supported property indices.\n * The item(index) attribute must return the row with the given index index.\n * If there is no such row, then the method must return null.\n *\n * Each row must be represented by a native ordered dictionary data type. In the\n * JavaScript binding, this must be Object. Each row object must have one property\n * (or dictionary entry) per column, with those properties enumerating in the order\n * that these columns were returned by the database. Each property must have the\n * name of the column and the value of the cell, as they were returned by the database\n */\nexport interface SQLResultSetRowList {\n  length: number;\n  item(index: number): any;\n}\n\n/** 4.6 Errors and exceptions - asynchronous database API error\n */\nexport declare class SQLError {\n  static UNKNOWN_ERR: number; // = 0;\n  static DATABASE_ERR: number; // = 1;\n  static VERSION_ERR: number; // = 2;\n  static TOO_LARGE_ERR: number; // = 3;\n  static QUOTA_ERR: number; // = 4;\n  static SYNTAX_ERR: number; // = 5;\n  static CONSTRAINT_ERR: number; // = 6;\n  static TIMEOUT_ERR: number; // = 7;\n\n  code: number;\n  message: string;\n}\n\n// synchronous database API error\nexport declare class SQLException {\n  /** Code 0 - The transaction failed for reasons unrelated to the database itself\n   * and not covered by any other error code.\n   */\n  static UNKNOWN_ERR: number; // = 0;\n  /** Code 1 - The statement failed for database reasons not covered by any other error code. */\n  static DATABASE_ERR: number; // = 1;\n  /** Code 2 - The operation failed because the actual database version was not what it should be.\n   * For example, a statement found that the actual database version no longer matched the\n   * expected version of the Database or DatabaseSync object, or the Database.changeVersion()\n   * or DatabaseSync.changeVersion() methods were passed a version that doesn't match the actual database version.\n   */\n  static VERSION_ERR: number; // = 2;\n  /** Code 3 - The statement failed because the data returned from the database was too large.\n   * The SQL \"LIMIT\" modifier might be useful to reduce the size of the result set.\n   */\n  static TOO_LARGE_ERR: number; // = 3;\n  /** Code 4 - The statement failed because there was not enough remaining storage space,\n   * or the storage quota was reached and the user declined to give more space to the database.\n   */\n  static QUOTA_ERR: number; // = 4;\n  /** Code 5 - The statement failed because of a syntax error, or the number of arguments did\n   * not match the number of ? placeholders in the statement, or the statement tried to use a\n   * statement that is not allowed, such as BEGIN, COMMIT, or ROLLBACK, or the statement tried\n   * to use a verb that could modify the database but the transaction was read-only. */\n  static SYNTAX_ERR: number; // = 5;\n  /** Code 6 - An INSERT, UPDATE, or REPLACE statement failed due to a constraint failure.\n   * For example, because a row was being inserted and the value given for the primary\n   * key column duplicated the value of an existing row. */\n  static CONSTRAINT_ERR: number; // = 6;\n  /** Code 7 - A lock for the transaction could not be obtained in a reasonable time. */\n  static TIMEOUT_ERR: number; // = 7;\n\n  code: number;\n  message: string;\n}\n\nexport interface WebSQLDatabase extends Database {\n  exec(queries: Query[], readOnly: boolean, callback: SQLiteCallback): void;\n}\n\nexport type Query = { sql: string; args: unknown[] };\n\nexport interface ResultSetError {\n  error: Error;\n}\nexport interface ResultSet {\n  insertId?: number;\n  rowsAffected: number;\n  rows: Array<{ [column: string]: any }>;\n}\n\nexport type SQLiteCallback = (\n  error?: Error | null,\n  resultSet?: Array<ResultSetError | ResultSet>\n) => void;\n"]}