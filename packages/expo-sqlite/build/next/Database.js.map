{"version":3,"file":"Database.js","sourceRoot":"","sources":["../../src/next/Database.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,YAAY,EAAgB,MAAM,mBAAmB,CAAC;AAE/D,OAAO,UAAU,MAAM,kBAAkB,CAAC;AAE1C,OAAO,EAAyB,SAAS,EAAsB,MAAM,aAAa,CAAC;AAInF,MAAM,OAAO,GAAG,IAAI,YAAY,CAAC,UAAU,CAAC,CAAC;AAE7C;;GAEG;AACH,MAAM,OAAO,QAAQ;IAED;IACC;IAFnB,YACkB,MAAc,EACb,cAA8B;QAD/B,WAAM,GAAN,MAAM,CAAQ;QACb,mBAAc,GAAd,cAAc,CAAgB;IAC9C,CAAC;IAEJ;;OAEG;IACI,eAAe;QACpB,OAAO,IAAI,CAAC,cAAc,CAAC,eAAe,EAAE,CAAC;IAC/C,CAAC;IAED;;OAEG;IACI,oBAAoB;QACzB,OAAO,IAAI,CAAC,cAAc,CAAC,oBAAoB,EAAE,CAAC;IACpD,CAAC;IAED;;OAEG;IACI,UAAU;QACf,OAAO,IAAI,CAAC,cAAc,CAAC,UAAU,EAAE,CAAC;IAC1C,CAAC;IAED;;;;;OAKG;IACI,SAAS,CAAC,MAAc;QAC7B,OAAO,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;IAC/C,CAAC;IAED;;;;;OAKG;IACI,KAAK,CAAC,YAAY,CAAC,MAAc;QACtC,MAAM,eAAe,GAAG,IAAI,UAAU,CAAC,eAAe,EAAE,CAAC;QACzD,MAAM,IAAI,CAAC,cAAc,CAAC,YAAY,CAAC,eAAe,EAAE,MAAM,CAAC,CAAC;QAChE,OAAO,IAAI,SAAS,CAAC,IAAI,CAAC,cAAc,EAAE,eAAe,CAAC,CAAC;IAC7D,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;;OAsBG;IACI,KAAK,CAAC,gBAAgB,CAAC,IAAyB;QACrD,IAAI;YACF,MAAM,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;YAC9B,MAAM,IAAI,EAAE,CAAC;YACb,MAAM,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;SAChC;QAAC,OAAO,CAAC,EAAE;YACV,MAAM,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC;YACjC,MAAM,CAAC,CAAC;SACT;IACH,CAAC;IAED;;;;;;;;;;;;;;;;OAgBG;IACI,KAAK,CAAC,yBAAyB,CAAC,IAAyC;QAC9E,MAAM,WAAW,GAAG,MAAM,WAAW,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QACxD,IAAI;YACF,MAAM,WAAW,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;YACrC,MAAM,IAAI,CAAC,WAAW,CAAC,CAAC;YACxB,MAAM,WAAW,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC;SACvC;QAAC,OAAO,CAAC,EAAE;YACV,MAAM,WAAW,CAAC,SAAS,CAAC,UAAU,CAAC,CAAC;YACxC,MAAM,CAAC,CAAC;SACT;gBAAS;YACR,MAAM,WAAW,CAAC,UAAU,EAAE,CAAC;SAChC;IACH,CAAC;IAaM,KAAK,CAAC,QAAQ,CAAC,MAAc,EAAE,GAAG,MAAa;QACpD,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;QAClD,IAAI;YACF,OAAO,MAAM,SAAS,CAAC,QAAQ,CAAC,GAAG,MAAM,CAAC,CAAC;SAC5C;gBAAS;YACR,MAAM,SAAS,CAAC,aAAa,EAAE,CAAC;SACjC;IACH,CAAC;IAWM,KAAK,CAAC,QAAQ,CAAI,MAAc,EAAE,GAAG,MAAa;QACvD,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;QAClD,IAAI;YACF,OAAO,MAAM,SAAS,CAAC,QAAQ,CAAI,GAAG,MAAM,CAAC,CAAC;SAC/C;gBAAS;YACR,MAAM,SAAS,CAAC,aAAa,EAAE,CAAC;SACjC;IACH,CAAC;IAWM,KAAK,CAAC,CAAC,SAAS,CAAI,MAAc,EAAE,GAAG,MAAa;QACzD,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;QAClD,IAAI;YACF,KAAK,CAAC,CAAC,SAAS,CAAC,SAAS,CAAI,GAAG,MAAM,CAAC,CAAC;SAC1C;gBAAS;YACR,MAAM,SAAS,CAAC,aAAa,EAAE,CAAC;SACjC;IACH,CAAC;IAWM,KAAK,CAAC,QAAQ,CAAI,MAAc,EAAE,GAAG,MAAa;QACvD,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;QAClD,IAAI;YACF,OAAO,MAAM,SAAS,CAAC,QAAQ,CAAI,GAAG,MAAM,CAAC,CAAC;SAC/C;gBAAS;YACR,MAAM,SAAS,CAAC,aAAa,EAAE,CAAC;SACjC;IACH,CAAC;CAGF;AAED;;;;;;GAMG;AACH,MAAM,CAAC,KAAK,UAAU,iBAAiB,CAAC,MAAc,EAAE,OAAqB;IAC3E,MAAM,cAAc,GAAG,IAAI,UAAU,CAAC,cAAc,CAAC,MAAM,EAAE,OAAO,IAAI,EAAE,CAAC,CAAC;IAC5E,MAAM,cAAc,CAAC,SAAS,EAAE,CAAC;IACjC,OAAO,IAAI,QAAQ,CAAC,MAAM,EAAE,cAAc,CAAC,CAAC;AAC9C,CAAC;AAED;;;;GAIG;AACH,MAAM,CAAC,KAAK,UAAU,mBAAmB,CAAC,MAAc;IACtD,OAAO,MAAM,UAAU,CAAC,mBAAmB,CAAC,MAAM,CAAC,CAAC;AACtD,CAAC;AAED;;;;;;GAMG;AACH,MAAM,UAAU,yBAAyB,CACvC,QAA+E;IAE/E,OAAO,OAAO,CAAC,WAAW,CAAC,kBAAkB,EAAE,QAAQ,CAAC,CAAC;AAC3D,CAAC;AAED;;GAEG;AACH,MAAM,WAAY,SAAQ,QAAQ;IACzB,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,EAAY;QAC1C,MAAM,cAAc,GAAG,IAAI,UAAU,CAAC,cAAc,CAAC,EAAE,CAAC,MAAM,EAAE,EAAE,gBAAgB,EAAE,IAAI,EAAE,CAAC,CAAC;QAC5F,MAAM,cAAc,CAAC,SAAS,EAAE,CAAC;QACjC,OAAO,IAAI,WAAW,CAAC,EAAE,CAAC,MAAM,EAAE,cAAc,CAAC,CAAC;IACpD,CAAC;CACF","sourcesContent":["import { EventEmitter, Subscription } from 'expo-modules-core';\n\nimport ExpoSQLite from './ExpoSQLiteNext';\nimport { NativeDatabase, OpenOptions } from './NativeDatabase';\nimport { BindParams, RunResult, Statement, VariadicBindParams } from './Statement';\n\nexport { OpenOptions };\n\nconst emitter = new EventEmitter(ExpoSQLite);\n\n/**\n * A SQLite database.\n */\nexport class Database {\n  constructor(\n    public readonly dbName: string,\n    private readonly nativeDatabase: NativeDatabase\n  ) {}\n\n  /**\n   * Synchronous call to return whether the database is currently in a transaction.\n   */\n  public isInTransaction(): boolean {\n    return this.nativeDatabase.isInTransaction();\n  }\n\n  /**\n   * Asynchronous call to return whether the database is currently in a transaction.\n   */\n  public isInTransactionAsync(): Promise<boolean> {\n    return this.nativeDatabase.isInTransactionAsync();\n  }\n\n  /**\n   * Close the database.\n   */\n  public closeAsync(): Promise<void> {\n    return this.nativeDatabase.closeAsync();\n  }\n\n  /**\n   * Execute all SQL queries in the supplied string.\n   * > Note: The queries are not escaped for you! Be careful when constructing your queries.\n   *\n   * @param source A string containing all the SQL queries.\n   */\n  public execAsync(source: string): Promise<void> {\n    return this.nativeDatabase.execAsync(source);\n  }\n\n  /**\n   * Prepare a SQL statement.\n   *\n   * @param source A string containing the SQL query.\n   * @returns A `Statement` object.\n   */\n  public async prepareAsync(source: string): Promise<Statement> {\n    const nativeStatement = new ExpoSQLite.NativeStatement();\n    await this.nativeDatabase.prepareAsync(nativeStatement, source);\n    return new Statement(this.nativeDatabase, nativeStatement);\n  }\n\n  /**\n   * Execute a transaction and automatically commit/rollback based on the `task` result.\n   *\n   * > **Note:** This transaction is not exclusive and can be interrupted by other async queries.\n   * @example\n   * ```ts\n   * db.transactionAsync(async () => {\n   *   await db.execAsync('UPDATE test SET name = \"aaa\"');\n   *\n   *   //\n   *   // We cannot control the order of async/await order, so order of execution is not guaranteed.\n   *   // The following UPDATE query out of transaction may be executed here and break the expectation.\n   *   //\n   *\n   *   const result = await db.getAsync<{ name: string }>('SELECT name FROM Users');\n   *   expect(result?.name).toBe('aaa');\n   * });\n   * db.execAsync('UPDATE test SET name = \"bbb\"');\n   * ```\n   * If you worry about the order of execution, use `transactionExclusiveAsync` instead.\n   *\n   * @param task An async function to execute within a transaction.\n   */\n  public async transactionAsync(task: () => Promise<void>): Promise<void> {\n    try {\n      await this.execAsync('BEGIN');\n      await task();\n      await this.execAsync('COMMIT');\n    } catch (e) {\n      await this.execAsync('ROLLBACK');\n      throw e;\n    }\n  }\n\n  /**\n   * Execute a transaction and automatically commit/rollback based on the `task` result.\n   *\n   * The transaction may be exclusive.\n   * As long as the transaction is converted into a write transaction,\n   * the other async write queries will abort with `database is locked` error.\n   *\n   * @param task An async function to execute within a transaction. Any queries inside the transaction must be executed on the `txn` object.\n   * The `txn` object has the same interfaces as the `Database` object. You can use `txn` like a `Database` object.\n   *\n   * @example\n   * ```ts\n   * db.transactionExclusiveAsync(async (txn) => {\n   *   await txn.execAsync('UPDATE test SET name = \"aaa\"');\n   * });\n   * ```\n   */\n  public async transactionExclusiveAsync(task: (txn: Transaction) => Promise<void>): Promise<void> {\n    const transaction = await Transaction.createAsync(this);\n    try {\n      await transaction.execAsync('BEGIN');\n      await task(transaction);\n      await transaction.execAsync('COMMIT');\n    } catch (e) {\n      await transaction.execAsync('ROLLBACK');\n      throw e;\n    } finally {\n      await transaction.closeAsync();\n    }\n  }\n\n  //#region Statement API shorthands\n\n  /**\n   * Shorthand for `prepareAsync` and `Statement.runAsync`.\n   * Unlike `Statement.runAsync`, this method finalizes the statement after execution.\n   *\n   * @param source A string containing the SQL query.\n   * @param params Parameters to bind to the query.\n   */\n  public runAsync(source: string, ...params: VariadicBindParams): Promise<RunResult>;\n  public runAsync(source: string, params: BindParams): Promise<RunResult>;\n  public async runAsync(source: string, ...params: any[]): Promise<RunResult> {\n    const statement = await this.prepareAsync(source);\n    try {\n      return await statement.runAsync(...params);\n    } finally {\n      await statement.finalizeAsync();\n    }\n  }\n\n  /**\n   * Shorthand for `prepareAsync` and `Statement.getAsync`.\n   * Unlike `Statement.getAsync`, this method finalizes the statement after execution.\n   *\n   * @param source A string containing the SQL query.\n   * @param params Parameters to bind to the query.\n   */\n  public getAsync<T>(source: string, ...params: VariadicBindParams): Promise<T | null>;\n  public getAsync<T>(source: string, params: BindParams): Promise<T | null>;\n  public async getAsync<T>(source: string, ...params: any[]): Promise<T | null> {\n    const statement = await this.prepareAsync(source);\n    try {\n      return await statement.getAsync<T>(...params);\n    } finally {\n      await statement.finalizeAsync();\n    }\n  }\n\n  /**\n   * Shorthand for `prepareAsync` and `Statement.eachAsync`.\n   * Unlike `Statement.eachAsync`, this method finalizes the statement after execution.\n   *\n   * @param source A string containing the SQL query.\n   * @param params Parameters to bind to the query.\n   */\n  public eachAsync<T>(source: string, ...params: VariadicBindParams): AsyncIterableIterator<T>;\n  public eachAsync<T>(source: string, params: BindParams): AsyncIterableIterator<T>;\n  public async *eachAsync<T>(source: string, ...params: any[]): AsyncIterableIterator<T> {\n    const statement = await this.prepareAsync(source);\n    try {\n      yield* statement.eachAsync<T>(...params);\n    } finally {\n      await statement.finalizeAsync();\n    }\n  }\n\n  /**\n   * Shorthand for `prepareAsync` and `Statement.allAsync`.\n   * Unlike `Statement.allAsync`, this method finalizes the statement after execution.\n   *\n   * @param source A string containing the SQL query.\n   * @param params Parameters to bind to the query.\n   */\n  public allAsync<T>(source: string, ...params: VariadicBindParams): Promise<T[]>;\n  public allAsync<T>(source: string, params: BindParams): Promise<T[]>;\n  public async allAsync<T>(source: string, ...params: any[]): Promise<T[]> {\n    const statement = await this.prepareAsync(source);\n    try {\n      return await statement.allAsync<T>(...params);\n    } finally {\n      await statement.finalizeAsync();\n    }\n  }\n\n  //#endregion\n}\n\n/**\n * Open a database.\n *\n * @param dbName The name of the database file to open.\n * @param options Open options.\n * @returns Database object.\n */\nexport async function openDatabaseAsync(dbName: string, options?: OpenOptions): Promise<Database> {\n  const nativeDatabase = new ExpoSQLite.NativeDatabase(dbName, options ?? {});\n  await nativeDatabase.initAsync();\n  return new Database(dbName, nativeDatabase);\n}\n\n/**\n * Delete a database file.\n *\n * @param dbName The name of the database file to delete.\n */\nexport async function deleteDatabaseAsync(dbName: string): Promise<void> {\n  return await ExpoSQLite.deleteDatabaseAsync(dbName);\n}\n\n/**\n * Add a listener for database changes.\n * > Note: to enable this feature, you must set `enableChangeListener` to `true` when opening the database.\n *\n * @param listener A function that receives the `dbName`, `tableName` and `rowId` of the modified data.\n * @returns A `Subscription` object that you can call `remove()` on when you would like to unsubscribe the listener.\n */\nexport function addDatabaseChangeListener(\n  listener: (event: { dbName: string; tableName: string; rowId: number }) => void\n): Subscription {\n  return emitter.addListener('onDatabaseChange', listener);\n}\n\n/**\n * A new connection specific for `transactionExclusiveAsync`.\n */\nclass Transaction extends Database {\n  public static async createAsync(db: Database): Promise<Transaction> {\n    const nativeDatabase = new ExpoSQLite.NativeDatabase(db.dbName, { useNewConnection: true });\n    await nativeDatabase.initAsync();\n    return new Transaction(db.dbName, nativeDatabase);\n  }\n}\n"]}