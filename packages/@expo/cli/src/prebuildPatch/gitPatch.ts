import spawnAsync, { type SpawnOptions } from '@expo/spawn-async';
import fs from 'fs/promises';
import path from 'path';

export async function initializeGitRepoAsync(repoRoot: string) {
  try {
    await fs.rm(path.join(repoRoot, '.git'), { recursive: true, force: true });
  } catch {}
  await runGitAsync(['init'], { cwd: repoRoot });
  await generateDefaultGitignoreAsync(repoRoot);
}

export async function addAllToGitIndexAsync(repoRoot: string) {
  await runGitAsync(['add', '-A'], { cwd: repoRoot });
}

export async function commitAsync(repoRoot: string, message: string) {
  await runGitAsync(['commit', '-m', message], {
    cwd: repoRoot,
    env: {
      ...process.env,
      GIT_AUTHOR_NAME: 'expo-cng',
      GIT_COMMITTER_NAME: 'expo-cng',
      GIT_AUTHOR_EMAIL: 'noreply@expo.dev',
      GIT_COMMITTER_EMAIL: 'noreply@expo.dev',
    },
  });
}

export async function diffAsync(
  repoRoot: string,
  outputPatchFilePath: string,
  options: string[]
): Promise<void> {
  await runGitAsync(['diff', ...options, '--output', outputPatchFilePath], {
    cwd: repoRoot,
  });
}

async function runGitAsync(
  args: string[],
  options: { cwd: string } & Partial<SpawnOptions>
): Promise<string> {
  const { stdout } = await spawnAsync('git', args, options);
  return stdout.trim();
}

async function generateDefaultGitignoreAsync(repoRoot: string) {
  const contents = `\
# These files are generated by pod install and should not be included in patch files.
Podfile.lock
contents.xcworkspacedata
`;
  await fs.writeFile(path.join(repoRoot, '.gitignore'), contents, 'utf8');
}
